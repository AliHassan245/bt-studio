<root>
    <BehaviorTree ID="MainTree">
        <ReactiveSequence name="main_seq">
            <ReactiveFallback name="obs_fallback">
                <CheckObstacle name="check_obstacle" obs_port="{n_obs}" amplitude="20" />
                <Turn name="avoid_obstacle" />
            </ReactiveFallback>
            <Forward name="move_forward" speed="0.2" obs_port="{n_obs}" />
        </ReactiveSequence>
    </BehaviorTree>
    <Code>
        <Turn>
            import py_trees
            import geometry_msgs
            
            class Turn(py_trees.behaviour.Behaviour):
            
                def __init__(self, name, ports = None):
            
                    """ Constructor, executed when the class is instantiated """
            
                    # Configure the name of the behaviour
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                    # Get the ports
                    self.ports = ports
            
                def setup(self, **kwargs: int) -&gt; None:
            
                    """ Executed when the setup function is called upon the tree """
            
                    # Get the node passed from the tree (needed for interaction with ROS)
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "Couldn't find the tree node"
                        raise KeyError(error_message) from e
                    
                    # Setup the publisher for the robot speed
                    self.publisher = self.node.create_publisher(
                        msg_type=geometry_msgs.msg.Twist,
                        topic="/cmd_vel",
                        qos_profile=10
                    )
            
                def initialise(self) -&gt; None:
            
                    """ Executed when coming from an idle state """
            
                    # Debugging
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
            
                def update(self) -&gt; py_trees.common.Status:
            
                    """ Executed when the action is ticked. Do not block! """
            
                    # Publish the speed msg
                    msg = geometry_msgs.msg.Twist()
                    msg.angular.z = 0.4
                    self.publisher.publish(msg)
            
                    return py_trees.common.Status.RUNNING 
                
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """ Called whenever the behaviour switches to a non-running state """
            
                    # Debugging
                    self.logger.debug("%s.terminate()[%s-&gt;%s]" % (self.__class__.__name__, self.status, new_status))
            
        </Turn>
        <CheckObstacle>
            import py_trees
            import sensor_msgs
            from tree_gardener import tree_tools
            
            def check_obstacle_in_laser(laser_measures, amplitude):
                    
                    relevant_measures = laser_measures[:amplitude] + laser_measures[-amplitude:]
            
                    for measure in relevant_measures:
            
                        if measure &lt; 1:
                            return True
                        
                    return False
            
            class CheckObstacle(py_trees.behaviour.Behaviour):
            
                def __init__(self, name, ports = None):
            
                    """ Constructor, executed when the class is instantiated """
            
                    # Configure the name of the behaviour
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                    # Get the ports
                    self.ports = ports
            
                def setup(self, **kwargs: int) -&gt; None:
            
                    """ Executed when the setup function is called upon the tree """
            
                    # Get the node passed from the tree (needed for interaction with ROS)
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "Couldn't find the tree node"
                        raise KeyError(error_message) from e
            
                    # Setup the subscription to the laser
                    self.subscription = self.node.create_subscription(
                        sensor_msgs.msg.LaserScan,
                        '/scan',
                        self.listener_callback,
                        10)
                
                    self.scan = sensor_msgs.msg.LaserScan()
            
                    # Init the obstacle counter
                    self.n_obs = 0
            
                def listener_callback(self, msg) -&gt; None:
                    self.scan = msg
            
                def initialise(self) -&gt; None:
            
                    """ Executed when coming from an idle state """
            
                    # Debugging
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
            
                def update(self) -&gt; py_trees.common.Status:
            
                    """ Executed when the action is ticked. Do not block! """
            
                    # Check the laser measures
                    if len(self.scan.ranges) == 0: new_status = py_trees.common.Status.INVALID
            
                    # Check if there is an obstacle
                    amplitude = int(tree_tools.get_port_content(self.ports["amplitude"]))
                    obstacle = check_obstacle_in_laser(self.scan.ranges, amplitude)
                    if not obstacle: new_status = py_trees.common.Status.SUCCESS
                    else: 
                        self.n_obs += 1
                        tree_tools.set_port_content(self.ports["obs_port"], self.n_obs)
                        new_status = py_trees.common.Status.FAILURE
            
                    return new_status
            
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """ Called whenever the behaviour switches to a non-running state """
            
                    # Debugging
                    self.logger.debug("%s.terminate()[%s-&gt;%s]" % (self.__class__.__name__, self.status, new_status))
            
        </CheckObstacle>
        <Forward>
            import py_trees
            import geometry_msgs
            import std_msgs
            from tree_gardener import tree_tools
            
            class Forward(py_trees.behaviour.Behaviour):
            
                def __init__(self, name, ports = None):
            
                    """ Constructor, executed when the class is instantiated """
            
                    # Configure the name of the behaviour
                    super().__init__(name)
                    self.logger.debug("%s.__init__()" % (self.__class__.__name__))
            
                    # Get the ports
                    self.ports = ports
            
                def setup(self, **kwargs) -&gt; None:
            
                    """ Executed when the setup function is called upon the tree """
            
                    # Get the node passed from the tree (needed for interaction with ROS)
                    try:
                        self.node = kwargs['node']
                    except KeyError as e:
                        error_message = "Couldn't find the tree node"
                        raise KeyError(error_message) from e
            
                    # Setup the publisher for the robot speed
                    self.publisher = self.node.create_publisher(
                        msg_type=geometry_msgs.msg.Twist,
                        topic="/cmd_vel",
                        qos_profile=10
                    )
            
                    # Setup the publisher for n_obs
                    self.publisher2 = self.node.create_publisher(
                        msg_type=std_msgs.msg.String,
                        topic="/n_obs",
                        qos_profile=10
                    )
            
                def initialise(self) -&gt; None:
            
                    """ Executed when coming from an idle state """
            
                    # Debugging
                    self.logger.debug("%s.initialise()" % (self.__class__.__name__))
            
                def update(self) -&gt; py_trees.common.Status:
            
                    """ Executed when the action is ticked. Do not block! """
            
                    # Publish the speed msg
                    msg = geometry_msgs.msg.Twist()
                    msg.linear.x = float(tree_tools.get_port_content(self.ports["speed"]))
                    self.publisher.publish(msg)
            
                    # Publish the number of obstacles retrieved from the port
                    nobs = tree_tools.get_port_content(self.ports["obs_port"])
                    str_pub = std_msgs.msg.String()
                    str_pub.data = str(nobs)
                    self.publisher2.publish(str_pub)
            
                    return py_trees.common.Status.RUNNING 
            
                def terminate(self, new_status: py_trees.common.Status) -&gt; None:
            
                    """ Called whenever the behaviour switches to a non-running state """
            
                    # Stop the robot
                    msg = geometry_msgs.msg.Twist()
                    msg.linear.x = 0.0
                    self.publisher.publish(msg)
            
                    # Debugging
                    self.logger.debug("%s.terminate()[%s-&gt;%s]" % (self.__class__.__name__, self.status, new_status))
        </Forward>
    </Code>
</root>